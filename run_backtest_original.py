import argparse
import sqlite3
import sys
from datetime import datetime
import pandas as pd

# –ò–º–ø–æ—Ä—Ç—ã –∏–∑ –ø—Ä–æ–µ–∫—Ç–∞
from basis_analyzer import BasisAnalyzer
from historical_analyzer import HistoricalAnalyzer
from prediction_layer import PredictionLayer
from error_monitor import ErrorMonitor
from block_detector import BlockDetector
from block_analyzer import BlockAnalyzer
from formula_engine_blocks import FormulaEngineBlocks

def load_data(symbol, tag, start_date, end_date):
    """
    –ó–∞–≥—Ä—É–∂–∞–µ—Ç –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∑–∞–¥–∞–Ω–Ω–æ–≥–æ —Å–∏–º–≤–æ–ª–∞ –∏ —Ç–µ–≥–∞.
    """
    conn = sqlite3.connect('server_opc.db')
    
    # –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö —Å–ø–æ—Ç–∞
    spot_query = '''
    SELECT time, close as spot_price FROM spot_data 
    WHERE symbol = ? AND dataset_tag = ? AND time BETWEEN ? AND ?
    ORDER BY time
    '''
    spot_df = pd.read_sql_query(spot_query, conn, params=(symbol, tag, start_date, end_date))
    
    # –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö —Ñ—å—é—á–µ—Ä—Å–æ–≤
    futures_query = '''
    SELECT time, close as futures_price FROM futures_data 
    WHERE symbol = ? AND dataset_tag = ? AND time BETWEEN ? AND ?
    ORDER BY time
    '''
    futures_df = pd.read_sql_query(futures_query, conn, params=(symbol, tag, start_date, end_date))
    
    # –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö IV
    iv_query = '''
    SELECT time, iv_30d as iv_mean_all, skew_30d as skew FROM iv_agg 
    WHERE timeframe = '1m' AND symbol = ? AND dataset_tag = ? AND time BETWEEN ? AND ?
    ORDER BY time
    '''
    iv_df = pd.read_sql_query(iv_query, conn, params=(symbol, tag, start_date, end_date))
    
    # –ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–Ω–¥–æ–≤
    trend_query = '''
    SELECT timestamp, confidence FROM trend_signals_15m 
    WHERE symbol = ? AND dataset_tag = ? AND timestamp BETWEEN ? AND ?
    ORDER BY timestamp
    '''
    trend_df = pd.read_sql_query(trend_query, conn, params=(symbol, tag, start_date, end_date))
    
    conn.close()
    
    # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –º–µ—Ç–æ–∫
    spot_df['time'] = pd.to_datetime(spot_df['time'])
    futures_df['time'] = pd.to_datetime(futures_df['time'])
    iv_df['time'] = pd.to_datetime(iv_df['time'])
    trend_df['timestamp'] = pd.to_datetime(trend_df['timestamp'])
    
    # –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ –≤—Ä–µ–º–µ–Ω–Ω—ã–º –º–µ—Ç–∫–∞–º
    # –°–Ω–∞—á–∞–ª–∞ –æ–±—ä–µ–¥–∏–Ω—è–µ–º —Å–ø–æ—Ç –∏ —Ñ—å—é—á–µ—Ä—Å—ã
    merged_df = pd.merge_asof(
        spot_df.sort_values('time'),
        futures_df.sort_values('time'),
        on='time',
        direction='nearest',
        tolerance=pd.Timedelta('1min')
    )
    
    # –ó–∞—Ç–µ–º –¥–æ–±–∞–≤–ª—è–µ–º IV –¥–∞–Ω–Ω—ã–µ
    merged_df = pd.merge_asof(
        merged_df,
        iv_df.sort_values('time'),
        on='time',
        direction='nearest',
        tolerance=pd.Timedelta('1min')
    )
    
    # –ù–∞–∫–æ–Ω–µ—Ü, –¥–æ–±–∞–≤–ª—è–µ–º —Ç—Ä–µ–Ω–¥—ã
    merged_df = pd.merge_asof(
        merged_df,
        trend_df.sort_values('timestamp'),
        left_on='time',
        right_on='timestamp',
        direction='backward',
        tolerance=pd.Timedelta('15min')
    )
    
    return merged_df

def run_backtest(symbol, tag, start_date, end_date):
    """
    –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –±—ç–∫—Ç–µ—Å—Ç–∞.
    """
    print(f"–ó–∞–ø—É—Å–∫ –±—ç–∫—Ç–µ—Å—Ç–∞ –¥–ª—è {symbol} —Å —Ç–µ–≥–æ–º {tag} —Å {start_date} –ø–æ {end_date}")
    
    # –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö
    data_df = load_data(symbol, tag, start_date, end_date)
    
    if data_df.empty:
        print("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞")
        return
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–æ–≤ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
    basis_analyzer = BasisAnalyzer(symbol=symbol, dataset_tag=tag)
    historical_analyzer = HistoricalAnalyzer(symbol=symbol, dataset_tag=tag)
    
    # –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è historical_analyzer
    historical_analyzer.load_historical_data()
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è PredictionLayer –∏ ErrorMonitor
    prediction_layer = PredictionLayer(window_size=5)
    error_monitor = ErrorMonitor()
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–≥–æ –º–µ—Ö–∞–Ω–∏–∑–º–∞
    block_detector = BlockDetector('server_opc.db')
    block_analyzer = BlockAnalyzer('server_opc.db')
    formula_engine_blocks = FormulaEngineBlocks('server_opc.db')
    
    # –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Ä—ã–Ω–æ—á–Ω—ã—Ö —Ä–µ–∂–∏–º–æ–≤
    market_regimes = {}  # –°–ª–æ–≤–∞—Ä—å –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞ —Ä–µ–∂–∏–º–æ–≤
    current_regime = 'unknown'  # –¢–µ–∫—É—â–∏–π —Ä—ã–Ω–æ—á–Ω—ã–π —Ä–µ–∂–∏–º
    current_parameters = {'threshold': 0.7}  # –¢–µ–∫—É—â–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ñ–æ—Ä–º—É–ª—ã
    
    # –°–æ–∑–¥–∞–Ω–∏–µ —Ü–∏–∫–ª–∞ –ø–æ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–º –¥–∞–Ω–Ω—ã–º
    for index, row in data_df.iterrows():
        # –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –±–ª–æ–∫–æ–≤ (–∫–∞–∂–¥—ã–µ 100 –∏—Ç–µ—Ä–∞—Ü–∏–π)
        if index > 0 and index % 100 == 0:
            print(f"üîç –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –±–ª–æ–∫–æ–≤ –Ω–∞ –∏—Ç–µ—Ä–∞—Ü–∏–∏ {index}")
            
            # –ü–æ–ª—É—á–∞–µ–º —Å–≤–µ–∂—É—é –∏—Å—Ç–æ—Ä–∏—é –æ—à–∏–±–æ–∫ (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 500 –∑–∞–ø–∏—Å–µ–π)
            error_history = error_monitor.get_errors()
            if len(error_history) > 500:
                error_history = error_history.tail(500)
            
            if not error_history.empty:
                # –û–±–Ω–∞—Ä—É–∂–∏–≤–∞–µ–º –±–ª–æ–∫–∏
                blocks = block_detector.detect_block_boundaries(error_history, threshold=1.5, window=50)
                
                if len(blocks) > 0:
                    # –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –±–ª–æ–∫
                    latest_block = blocks[-1]
                    
                    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –±–ª–æ–∫ –≤ –ë–î
                    block_detector.save_blocks([latest_block])
                    
                    # –ü–æ–ª—É—á–∞–µ–º ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –±–ª–æ–∫–∞ –∏–∑ –ë–î
                    blocks_df = block_detector.get_blocks()
                    if not blocks_df.empty:
                        latest_block_id = blocks_df.iloc[-1]['id']
                        
                        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –±–ª–æ–∫ –∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä—ã–Ω–æ—á–Ω—ã–π —Ä–µ–∂–∏–º
                        market_regime = block_analyzer.classify_market_regime(latest_block_id)
                        print(f"üìä –û–±–Ω–∞—Ä—É–∂–µ–Ω —Ä—ã–Ω–æ—á–Ω—ã–π —Ä–µ–∂–∏–º: {market_regime}")
                        
                        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ä–µ–∂–∏–º–æ–≤
                        if market_regime in market_regimes:
                            market_regimes[market_regime] += 1
                        else:
                            market_regimes[market_regime] = 1
                        
                        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π —Ä–µ–∂–∏–º
                        current_regime = market_regime
                        
                        # –ê–¥–∞–ø—Ç–∏—Ä—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ñ–æ—Ä–º—É–ª—ã
                        current_parameters = formula_engine_blocks.get_formula_parameters(
                            'balanced', latest_block_id, market_regime
                        )
                        print(f"‚öôÔ∏è –ê–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω—ã –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è —Ä–µ–∂–∏–º–∞ {market_regime}: {current_parameters}")
        
        # –ü—Ä–æ–≥–Ω–æ–∑–∏—Ä–æ–≤–∞–Ω–∏–µ
        historical_prices = data_df['spot_price'].iloc[:index]
        if len(historical_prices) > 5:  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –¥–ª—è –ø—Ä–æ–≥–Ω–æ–∑–∞
            predicted_price = prediction_layer.predict_next_price(historical_prices)
        else:
            predicted_price = row['spot_price']  # –ï—Å–ª–∏ –¥–∞–Ω–Ω—ã—Ö –º–∞–ª–æ, –ø—Ä–æ–≥–Ω–æ–∑ = —Ç–µ–∫—É—â–∞—è —Ü–µ–Ω–∞
        
        # –§–∞–∫—Ç–∏—á–µ—Å–∫–∞—è —Ü–µ–Ω–∞
        actual_price = row['spot_price']
        
        # –ó–∞–ø–∏—Å—å –æ—à–∏–±–∫–∏
        if index > 0:  # –ù–∞—á–∏–Ω–∞–µ–º –∑–∞–ø–∏—Å—å –æ—à–∏–±–æ–∫ —Å–æ –≤—Ç–æ—Ä–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏
            volatility = abs(actual_price - data_df['spot_price'].iloc[index-1]) if index > 0 else 0
            error_monitor.update(
                timestamp=row['time'],
                predicted=predicted_price,
                actual=actual_price,
                volatility=volatility,
                formula_id='F01',
                confidence=1.0,
                method='simple_moving_average'
            )
        
        # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–æ–≤
        # –î–ª—è basis_analyzer –Ω–∞–º –Ω—É–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å –µ–≥–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –¥–∞–Ω–Ω—ã–µ
        # –ü–æ—Å–∫–æ–ª—å–∫—É –º–µ—Ç–æ–¥ analyze_current_basis –Ω–µ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤,
        # –º—ã —Å–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã –≤ –ë–î –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —à–∞–≥–∞
        # –≠—Ç–æ –Ω–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ, –Ω–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É
        
        # –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ, –º–æ–∂–Ω–æ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å BasisAnalyzer –¥–ª—è –ø—Ä–∏–µ–º–∞ –¥–∞–Ω–Ω—ã—Ö
        # –ù–æ –¥–ª—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º –∑–∞–¥–∞—á–∏ –æ—Å—Ç–∞–≤–∏–º –∫–∞–∫ –µ—Å—Ç—å
        
        # –î–ª—è historical_analyzer —Ñ–æ—Ä–º–∏—Ä—É–µ–º current_signal
        current_signal = {
            'iv_spike': row['iv_mean_all'] if pd.notna(row['iv_mean_all']) else 0,
            'skew': row['skew'] if pd.notna(row['skew']) else 0,
            'trend_confidence': row['confidence'] if pd.notna(row['confidence']) else 0,
            'direction': 'NEUTRAL',  # –ó–∞–≥–ª—É—à–∫–∞, —Ç–∞–∫ –∫–∞–∫ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ
            'spot_price': row['spot_price'] if pd.notna(row['spot_price']) else 0
        }
        
        # –í—ã–∑–æ–≤ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–æ–≤
        # –î–ª—è basis_analyzer –ø–µ—Ä–µ–¥–∞–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞
        basis_data = {
            'spot_price': row['spot_price'] if pd.notna(row['spot_price']) else 0,
            'futures_price': row['futures_price'] if pd.notna(row['futures_price']) else 0
        }
        basis_result = basis_analyzer.analyze_current_basis(basis_data)
        historical_result = historical_analyzer.find_analogies(current_signal)
        
        # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –Ω–æ–≤–æ—Å—Ç–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
        news_result = {'score': 0.5, 'sentiment': 'NEUTRAL'}
        
        # –ê–≥—Ä–µ–≥–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
        # –ü—Ä–æ—Å—Ç–∞—è –≤–∑–≤–µ—à–µ–Ω–Ω–∞—è —Å—É–º–º–∞ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
        basis_weight = current_parameters.get('basis_weight', 0.4)
        historical_weight = 0.4  # –ú–æ–∂–Ω–æ —Ç–∞–∫–∂–µ –∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞—Ç—å
        news_weight = 0.2
        
        # –î–ª—è historical_result –∏—Å–ø–æ–ª—å–∑—É–µ–º win_rate –∫–∞–∫ score
        historical_score = historical_result.get('win_rate', 0)
        
        final_score = (basis_result.get('score', 0) * basis_weight +
                      historical_score * historical_weight +
                      news_result.get('score', 0) * news_weight)
        
        # –ü—Ä–∏–Ω—è—Ç–∏–µ —Ä–µ—à–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Å—á–µ—Ç–∞ –∏ –∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ—Ä–æ–≥–∞
        threshold = current_parameters.get('threshold', 0.7)
        if final_score > threshold + 0.1:  # STRONG BUY
            decision = "STRONG BUY"
        elif final_score > threshold:  # BUY
            decision = "BUY"
        elif final_score < threshold - 0.4:  # SELL
            decision = "SELL"
        elif final_score < threshold - 0.3:  # STRONG SELL
            decision = "STRONG SELL"
        else:
            decision = "HOLD"
        
        # –í—ã–≤–æ–¥ –æ—Ç—á–µ—Ç–∞, –µ—Å–ª–∏ —Ä–µ—à–µ–Ω–∏–µ –Ω–µ HOLD
        if decision != "HOLD":
            timestamp = row['time'] if pd.notna(row['time']) else "N/A"
            report = {
                'timestamp': timestamp,
                'decision': decision,
                'basis_score': basis_result.get('score', 0),
                'historical_score': historical_score,
                'news_score': news_result.get('score', 0),
                'final_score': final_score,
                'regime': current_regime,
                'threshold': threshold
            }
            print(f"–û—Ç—á–µ—Ç: {report}")

# –§–∏–Ω–∞–ª—å–Ω–∞—è –æ—Ç—á–µ—Ç–Ω–æ—Å—Ç—å –ø–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã–º —Ä–µ–∂–∏–º–∞–º
print("\n" + "="*50)
print("--- –°–í–û–î–ö–ê –ü–û –†–´–ù–û–ß–ù–´–ú –†–ï–ñ–ò–ú–ê–ú ---")

if market_regimes:
total_regimes = sum(market_regimes.values())
print(f"–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ {len(market_regimes)} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Ä–µ–∂–∏–º–∞:")

# –°–æ—Ä—Ç–∏—Ä—É–µ–º —Ä–µ–∂–∏–º—ã –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–π
sorted_regimes = sorted(market_regimes.items(), key=lambda x: x[1], reverse=True)

for regime, count in sorted_regimes:
    percentage = (count / total_regimes) * 100
    # –°–∫–ª–æ–Ω–µ–Ω–∏–µ —Å–ª–æ–≤–∞ "—Ä–∞–∑" –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —á–∏—Å–ª–∞
    if count % 10 == 1 and count % 100 != 11:
        times_word = "—Ä–∞–∑"
    elif count % 10 in [2, 3, 4] and count % 100 not in [12, 13, 14]:
        times_word = "—Ä–∞–∑–∞"
    else:
        times_word = "—Ä–∞–∑"
    print(f"- {regime.upper()}: {count} {times_word} ({percentage:.1f}%)")
else:
print("–†–µ–∂–∏–º—ã –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã")

print("-" * 36)
print("=" * 50)

def main():
    parser = argparse.ArgumentParser(description='–ó–∞–ø—É—Å–∫ –±—ç–∫—Ç–µ—Å—Ç–∞ –¥–ª—è –∑–∞–¥–∞–Ω–Ω–æ–≥–æ –∞–∫—Ç–∏–≤–∞ –∏ –Ω–∞–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö.')
    parser.add_argument('--symbol', required=True, help='–°–∏–º–≤–æ–ª –∞–∫—Ç–∏–≤–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, BTCUSDT –∏–ª–∏ SOLUSDT)')
    parser.add_argument('--tag', required=True, help='–¢–µ–≥ –Ω–∞–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä, training_2023)')
    parser.add_argument('--start', required=True, help='–î–∞—Ç–∞ –Ω–∞—á–∞–ª–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 2023-01-01)')
    parser.add_argument('--end', required=True, help='–î–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, 2023-01-07)')
    
    args = parser.parse_args()
    
    run_backtest(args.symbol, args.tag, args.start, args.end)

if __name__ == "__main__":
    main()