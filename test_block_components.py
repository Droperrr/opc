#!/usr/bin/env python3
"""
–¢–µ—Å—Ç—ã –¥–ª—è –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ Error-Driven Blocks
–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é Block Detector, Block Analyzer, Formula Engine –∏ Block Reporting
"""

import sys
import os
import unittest
import sqlite3
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
import logging
import uuid
import json

# –î–æ–±–∞–≤–ª—è–µ–º –ø—É—Ç—å –∫ –º–æ–¥—É–ª—è–º
sys.path.append('.')

from block_detector import BlockDetector, BlockBoundary
from block_analyzer import BlockAnalyzer, BlockAnalysis
from formula_engine_blocks import FormulaEngineBlocks
from block_reporting import BlockReporter

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TestBlockComponents(unittest.TestCase):
    """–¢–µ—Å—Ç—ã –¥–ª—è –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ –±–ª–æ–∫–æ–≤"""
    
    def setUp(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ç–µ—Å—Ç–æ–≤"""
        self.test_db = f'test_blocks_{uuid.uuid4().hex[:8]}.db'
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
        self.block_detector = BlockDetector(self.test_db)
        self.block_analyzer = BlockAnalyzer(self.test_db)
        self.formula_engine = FormulaEngineBlocks(self.test_db)
        self.block_reporter = BlockReporter(self.test_db)
        
        # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
        self._create_test_data()
    
    def tearDown(self):
        """–û—á–∏—Å—Ç–∫–∞ –ø–æ—Å–ª–µ —Ç–µ—Å—Ç–æ–≤"""
        try:
            if os.path.exists(self.test_db):
                os.remove(self.test_db)
        except PermissionError:
            pass
    
    def _create_test_data(self):
        """–°–æ–∑–¥–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤"""
        try:
            with sqlite3.connect(self.test_db) as conn:
                cursor = conn.cursor()
                
                # –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—ã
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS error_history (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        timestamp DATETIME NOT NULL,
                        formula_id TEXT,
                        prediction REAL NOT NULL,
                        actual REAL NOT NULL,
                        error_absolute REAL NOT NULL,
                        error_relative REAL NOT NULL,
                        error_normalized REAL NOT NULL,
                        volatility REAL,
                        confidence REAL,
                        method TEXT,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                    )
                ''')
                
                # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –æ—à–∏–±–∫–∏ —Å —Ä–∞–∑–Ω—ã–º–∏ —Ä–µ–∂–∏–º–∞–º–∏
                np.random.seed(42)
                
                # –†–µ–∂–∏–º 1: –°—Ç–∞–±–∏–ª—å–Ω—ã–µ –Ω–∏–∑–∫–∏–µ –æ—à–∏–±–∫–∏
                for i in range(100):
                    timestamp = datetime.now() - timedelta(hours=3, minutes=i)
                    error = np.random.normal(0.3, 0.1)
                    cursor.execute('''
                        INSERT INTO error_history 
                        (timestamp, formula_id, prediction, actual, error_absolute, 
                         error_relative, error_normalized, volatility, confidence, method)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        timestamp, 'volatility_focused', 100.0, 100.0 + error, abs(error),
                        abs(error)/100.0, abs(error)/0.01, 0.01, 0.8, 'sma'
                    ))
                
                # –†–µ–∂–∏–º 2: –í–æ–ª–∞—Ç–∏–ª—å–Ω—ã–µ –≤—ã—Å–æ–∫–∏–µ –æ—à–∏–±–∫–∏
                for i in range(100):
                    timestamp = datetime.now() - timedelta(hours=2, minutes=i)
                    error = np.random.normal(1.5, 0.5)
                    cursor.execute('''
                        INSERT INTO error_history 
                        (timestamp, formula_id, prediction, actual, error_absolute, 
                         error_relative, error_normalized, volatility, confidence, method)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        timestamp, 'volatility_focused', 100.0, 100.0 + error, abs(error),
                        abs(error)/100.0, abs(error)/0.05, 0.05, 0.6, 'sma'
                    ))
                
                # –†–µ–∂–∏–º 3: –°—Ä–µ–¥–Ω–∏–µ –æ—à–∏–±–∫–∏
                for i in range(100):
                    timestamp = datetime.now() - timedelta(hours=1, minutes=i)
                    error = np.random.normal(0.8, 0.2)
                    cursor.execute('''
                        INSERT INTO error_history 
                        (timestamp, formula_id, prediction, actual, error_absolute, 
                         error_relative, error_normalized, volatility, confidence, method)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        timestamp, 'volatility_focused', 100.0, 100.0 + error, abs(error),
                        abs(error)/100.0, abs(error)/0.02, 0.02, 0.7, 'sma'
                    ))
                
                conn.commit()
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–µ—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö: {e}")
    
    def test_block_detector_integration(self):
        """–¢–µ—Å—Ç 1: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è Block Detector"""
        logger.info("üß™ –¢–µ—Å—Ç 1: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è Block Detector")
        
        try:
            # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ–± –æ—à–∏–±–∫–∞—Ö
            with sqlite3.connect(self.test_db) as conn:
                df = pd.read_sql_query("SELECT * FROM error_history ORDER BY timestamp", conn)
            
            # –û–±–Ω–∞—Ä—É–∂–∏–≤–∞–µ–º –±–ª–æ–∫–∏
            blocks = self.block_detector.detect_block_boundaries(df, threshold=1.5, window=50)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            self.assertGreater(len(blocks), 0, "–î–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã –±–ª–æ–∫–∏")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –±–ª–æ–∫–æ–≤
            for block in blocks:
                self.assertIsInstance(block, BlockBoundary)
                self.assertIsNotNone(block.start_time)
                self.assertIsNotNone(block.end_time)
                self.assertIsNotNone(block.block_type)
                self.assertGreaterEqual(block.confidence, 0.0)
                self.assertLessEqual(block.confidence, 1.0)
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –±–ª–æ–∫–∏
            self.block_detector.save_blocks(blocks)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
            saved_blocks = self.block_detector.get_blocks()
            self.assertEqual(len(saved_blocks), len(blocks), "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –±–ª–æ–∫–æ–≤ –¥–æ–ª–∂–Ω–æ —Å–æ–≤–ø–∞–¥–∞—Ç—å")
            
            logger.info("‚úÖ –¢–µ—Å—Ç 1: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è Block Detector ‚Üí PASSED")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∞ Block Detector: {e}")
            self.fail(f"–¢–µ—Å—Ç Block Detector –ø—Ä–æ–≤–∞–ª–µ–Ω: {e}")
    
    def test_block_analyzer_integration(self):
        """–¢–µ—Å—Ç 2: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è Block Analyzer"""
        logger.info("üß™ –¢–µ—Å—Ç 2: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è Block Analyzer")
        
        try:
            # –°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–µ–º –±–ª–æ–∫–∏
            with sqlite3.connect(self.test_db) as conn:
                df = pd.read_sql_query("SELECT * FROM error_history ORDER BY timestamp", conn)
            
            blocks = self.block_detector.detect_block_boundaries(df, threshold=1.5, window=50)
            self.block_detector.save_blocks(blocks)
            
            # –¢–µ—Å—Ç–∏—Ä—É–µ–º –∞–Ω–∞–ª–∏–∑ –±–ª–æ–∫–∞
            if len(blocks) > 0:
                block_id = blocks[0].start_index  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏–Ω–¥–µ–∫—Å –∫–∞–∫ ID
                
                # –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –±–ª–æ–∫–∞
                statistics = self.block_analyzer.get_block_statistics(1)  # –ò—Å–ø–æ–ª—å–∑—É–µ–º ID=1
                
                if statistics:
                    self.assertIn('block_id', statistics)
                    self.assertIn('mean_error', statistics)
                    self.assertIn('std_error', statistics)
                
                # –ö–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä—É–µ–º —Ä—ã–Ω–æ—á–Ω—ã–π —Ä–µ–∂–∏–º
                market_regime = self.block_analyzer.classify_market_regime(1)
                self.assertIsInstance(market_regime, str)
                self.assertIn(market_regime, ['trending', 'volatile', 'stable', 'transition', 'unknown'])
                
                # –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª–Ω—ã–π –∞–Ω–∞–ª–∏–∑
                analysis = self.block_analyzer.analyze_block(1)
                self.assertIsInstance(analysis, BlockAnalysis)
                self.assertIsNotNone(analysis.market_regime)
                self.assertIsNotNone(analysis.risk_level)
                self.assertIsInstance(analysis.recommendations, list)
                
                # –ü–æ–ª—É—á–∞–µ–º —Å–≤–æ–¥–∫—É
                summary = self.block_analyzer.get_blocks_summary(1)
                self.assertIsInstance(summary, dict)
            
            logger.info("‚úÖ –¢–µ—Å—Ç 2: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è Block Analyzer ‚Üí PASSED")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∞ Block Analyzer: {e}")
            self.fail(f"–¢–µ—Å—Ç Block Analyzer –ø—Ä–æ–≤–∞–ª–µ–Ω: {e}")
    
    def test_formula_engine_integration(self):
        """–¢–µ—Å—Ç 3: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è Formula Engine —Å –±–ª–æ–∫–∞–º–∏"""
        logger.info("üß™ –¢–µ—Å—Ç 3: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è Formula Engine —Å –±–ª–æ–∫–∞–º–∏")
        
        try:
            # –°–æ–∑–¥–∞–µ–º –±–ª–æ–∫–∏
            with sqlite3.connect(self.test_db) as conn:
                df = pd.read_sql_query("SELECT * FROM error_history ORDER BY timestamp", conn)
            
            blocks = self.block_detector.detect_block_boundaries(df, threshold=1.5, window=50)
            self.block_detector.save_blocks(blocks)
            
            # –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–ª—É—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
            params = self.formula_engine.get_formula_parameters('volatility_focused', block_id=1)
            self.assertIsInstance(params, dict)
            self.assertIn('threshold', params)
            
            # –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–ª—É—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –±–ª–æ–∫–∞
            current_params = self.formula_engine.get_current_block_parameters('volatility_focused')
            self.assertIsInstance(current_params, dict)
            self.assertIn('parameters', current_params)
            self.assertIn('market_regime', current_params)
            
            # –¢–µ—Å—Ç–∏—Ä—É–µ–º –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—é –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
            optimized_params = self.formula_engine.optimize_parameters_for_regime('volatility_focused', 'stable')
            self.assertIsInstance(optimized_params, dict)
            self.assertIn('threshold', optimized_params)
            
            # –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ñ–æ—Ä–º—É–ª—ã
            performance = self.formula_engine.get_formula_performance_by_regime('volatility_focused')
            self.assertIsInstance(performance, dict)
            
            logger.info("‚úÖ –¢–µ—Å—Ç 3: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è Formula Engine —Å –±–ª–æ–∫–∞–º–∏ ‚Üí PASSED")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∞ Formula Engine: {e}")
            self.fail(f"–¢–µ—Å—Ç Formula Engine –ø—Ä–æ–≤–∞–ª–µ–Ω: {e}")
    
    def test_block_reporting_integration(self):
        """–¢–µ—Å—Ç 4: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è Block Reporting"""
        logger.info("üß™ –¢–µ—Å—Ç 4: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è Block Reporting")
        
        try:
            # –°–æ–∑–¥–∞–µ–º –±–ª–æ–∫–∏
            with sqlite3.connect(self.test_db) as conn:
                df = pd.read_sql_query("SELECT * FROM error_history ORDER BY timestamp", conn)
            
            blocks = self.block_detector.detect_block_boundaries(df, threshold=1.5, window=50)
            self.block_detector.save_blocks(blocks)
            
            # –¢–µ—Å—Ç–∏—Ä—É–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ –≥—Ä–∞—Ñ–∏–∫–æ–≤
            analysis_plot = self.block_reporter.create_block_analysis_plot(1)
            self.assertIsNotNone(analysis_plot)
            
            summary_plot = self.block_reporter.create_blocks_summary_plot(1)
            self.assertIsNotNone(summary_plot)
            
            formula_plot = self.block_reporter.create_formula_performance_plot('volatility_focused')
            self.assertIsNotNone(formula_plot)
            
            # –¢–µ—Å—Ç–∏—Ä—É–µ–º –∫–æ–º–ø–ª–µ–∫—Å–Ω—ã–π –æ—Ç—á–µ—Ç
            comprehensive_report = self.block_reporter.generate_comprehensive_report(1)
            self.assertIsInstance(comprehensive_report, dict)
            self.assertIn('blocks_summary', comprehensive_report)
            self.assertIn('key_insights', comprehensive_report)
            self.assertIn('recommendations', comprehensive_report)
            
            logger.info("‚úÖ –¢–µ—Å—Ç 4: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è Block Reporting ‚Üí PASSED")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∞ Block Reporting: {e}")
            self.fail(f"–¢–µ—Å—Ç Block Reporting –ø—Ä–æ–≤–∞–ª–µ–Ω: {e}")
    
    def test_end_to_end_workflow(self):
        """–¢–µ—Å—Ç 5: End-to-end workflow"""
        logger.info("üß™ –¢–µ—Å—Ç 5: End-to-end workflow")
        
        try:
            # –®–∞–≥ 1: –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ–± –æ—à–∏–±–∫–∞—Ö
            with sqlite3.connect(self.test_db) as conn:
                df = pd.read_sql_query("SELECT * FROM error_history ORDER BY timestamp", conn)
            
            self.assertGreater(len(df), 0, "–î–æ–ª–∂–Ω—ã –±—ã—Ç—å –¥–∞–Ω–Ω—ã–µ –æ–± –æ—à–∏–±–∫–∞—Ö")
            
            # –®–∞–≥ 2: –û–±–Ω–∞—Ä—É–∂–∏–≤–∞–µ–º –±–ª–æ–∫–∏
            blocks = self.block_detector.detect_block_boundaries(df, threshold=1.5, window=50)
            self.block_detector.save_blocks(blocks)
            
            self.assertGreater(len(blocks), 0, "–î–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã –±–ª–æ–∫–∏")
            
            # –®–∞–≥ 3: –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –±–ª–æ–∫–∏
            for i, block in enumerate(blocks[:3]):  # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–µ—Ä–≤—ã–µ 3 –±–ª–æ–∫–∞
                analysis = self.block_analyzer.analyze_block(i + 1)
                self.assertIsInstance(analysis, BlockAnalysis)
            
            # –®–∞–≥ 4: –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ñ–æ—Ä–º—É–ª –¥–ª—è –±–ª–æ–∫–æ–≤
            for i, block in enumerate(blocks[:3]):
                params = self.formula_engine.get_formula_parameters('volatility_focused', block_id=i + 1)
                self.assertIsInstance(params, dict)
            
            # –®–∞–≥ 5: –°–æ–∑–¥–∞–µ–º –æ—Ç—á–µ—Ç—ã
            comprehensive_report = self.block_reporter.generate_comprehensive_report(1)
            self.assertIsInstance(comprehensive_report, dict)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Ä–∞–±–æ—Ç–∞—é—Ç –≤–º–µ—Å—Ç–µ
            self.assertIn('blocks_summary', comprehensive_report)
            self.assertIn('block_analyses', comprehensive_report)
            self.assertIn('formula_performance', comprehensive_report)
            
            logger.info("‚úÖ –¢–µ—Å—Ç 5: End-to-end workflow ‚Üí PASSED")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ end-to-end —Ç–µ—Å—Ç–∞: {e}")
            self.fail(f"End-to-end —Ç–µ—Å—Ç –ø—Ä–æ–≤–∞–ª–µ–Ω: {e}")
    
    def test_error_handling(self):
        """–¢–µ—Å—Ç 6: –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫"""
        logger.info("üß™ –¢–µ—Å—Ç 6: –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫")
        
        try:
            # –¢–µ—Å—Ç —Å –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –±–ª–æ–∫–æ–º
            analysis = self.block_analyzer.analyze_block(99999)
            self.assertIsInstance(analysis, BlockAnalysis)
            self.assertEqual(analysis.block_id, 99999)
            
            # –¢–µ—Å—Ç —Å –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π —Ñ–æ—Ä–º—É–ª–æ–π
            params = self.formula_engine.get_formula_parameters('nonexistent_formula')
            self.assertIsInstance(params, dict)
            self.assertIn('threshold', params)
            
            # –¢–µ—Å—Ç —Å –ø—É—Å—Ç—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
            empty_df = pd.DataFrame()
            blocks = self.block_detector.detect_block_boundaries(empty_df)
            self.assertEqual(len(blocks), 0)
            
            logger.info("‚úÖ –¢–µ—Å—Ç 6: –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ ‚Üí PASSED")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫: {e}")
            self.fail(f"–¢–µ—Å—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ –ø—Ä–æ–≤–∞–ª–µ–Ω: {e}")
    
    def test_performance_metrics(self):
        """–¢–µ—Å—Ç 7: –ú–µ—Ç—Ä–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏"""
        logger.info("üß™ –¢–µ—Å—Ç 7: –ú–µ—Ç—Ä–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏")
        
        try:
            # –°–æ–∑–¥–∞–µ–º –±–ª–æ–∫–∏
            with sqlite3.connect(self.test_db) as conn:
                df = pd.read_sql_query("SELECT * FROM error_history ORDER BY timestamp", conn)
            
            blocks = self.block_detector.detect_block_boundaries(df, threshold=1.5, window=50)
            self.block_detector.save_blocks(blocks)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–µ—Ç—Ä–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
            if len(blocks) > 0:
                analysis = self.block_analyzer.analyze_block(1)
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –º–µ—Ç—Ä–∏–∫
                self.assertIsInstance(analysis.performance_metrics, dict)
                
                if analysis.performance_metrics:
                    self.assertIn('overall_score', analysis.performance_metrics)
                    overall_score = analysis.performance_metrics['overall_score']
                    self.assertGreaterEqual(overall_score, 0.0)
                    self.assertLessEqual(overall_score, 1.0)
            
            logger.info("‚úÖ –¢–µ—Å—Ç 7: –ú–µ—Ç—Ä–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ ‚Üí PASSED")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∞ –º–µ—Ç—Ä–∏–∫ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏: {e}")
            self.fail(f"–¢–µ—Å—Ç –º–µ—Ç—Ä–∏–∫ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –ø—Ä–æ–≤–∞–ª–µ–Ω: {e}")
    
    def test_data_consistency(self):
        """–¢–µ—Å—Ç 8: –ö–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö"""
        logger.info("üß™ –¢–µ—Å—Ç 8: –ö–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö")
        
        try:
            # –°–æ–∑–¥–∞–µ–º –±–ª–æ–∫–∏
            with sqlite3.connect(self.test_db) as conn:
                df = pd.read_sql_query("SELECT * FROM error_history ORDER BY timestamp", conn)
            
            blocks = self.block_detector.detect_block_boundaries(df, threshold=1.5, window=50)
            self.block_detector.save_blocks(blocks)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö
            saved_blocks = self.block_detector.get_blocks()
            
            for _, block in saved_blocks.iterrows():
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã
                self.assertLess(block['start_time'], block['end_time'])
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã
                self.assertGreaterEqual(block['mean_error'], 0.0)
                self.assertGreaterEqual(block['std_error'], 0.0)
                self.assertGreaterEqual(block['max_error'], block['min_error'])
                self.assertGreaterEqual(block['confidence'], 0.0)
                self.assertLessEqual(block['confidence'], 1.0)
            
            logger.info("‚úÖ –¢–µ—Å—Ç 8: –ö–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö ‚Üí PASSED")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∞ –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö: {e}")
            self.fail(f"–¢–µ—Å—Ç –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö –ø—Ä–æ–≤–∞–ª–µ–Ω: {e}")

def run_block_components_tests():
    """–ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö —Ç–µ—Å—Ç–æ–≤ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ –±–ª–æ–∫–æ–≤"""
    logger.info("üéØ –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ Error-Driven Blocks")
    logger.info(f"üìÖ –í—Ä–µ–º—è: {datetime.now()}")
    
    # –°–æ–∑–¥–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –Ω–∞–±–æ—Ä–∞
    suite = unittest.TestLoader().loadTestsFromTestCase(TestBlockComponents)
    
    # –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    # –ü–æ–¥—Å—á–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    total_tests = result.testsRun
    failed_tests = len(result.failures)
    error_tests = len(result.errors)
    passed_tests = total_tests - failed_tests - error_tests
    
    success_rate = (passed_tests / total_tests) * 100 if total_tests > 0 else 0
    
    logger.info("üìä –ò—Ç–æ–≥–æ–≤—ã–π –æ—Ç—á–µ—Ç —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ –±–ª–æ–∫–æ–≤:")
    logger.info(f"   –í—Å–µ–≥–æ —Ç–µ—Å—Ç–æ–≤: {total_tests}")
    logger.info(f"   –ü—Ä–æ–π–¥–µ–Ω–æ: {passed_tests}")
    logger.info(f"   –ü—Ä–æ–≤–∞–ª–µ–Ω–æ: {failed_tests}")
    logger.info(f"   –û—à–∏–±–æ–∫: {error_tests}")
    logger.info(f"   –£—Å–ø–µ—à–Ω–æ—Å—Ç—å: {success_rate:.1f}%")
    
    if success_rate >= 80:
        logger.info("üéâ –¢–ï–°–¢–´ –ö–û–ú–ü–û–ù–ï–ù–¢–û–í –ë–õ–û–ö–û–í –ü–†–û–ô–î–ï–ù–´!")
        return True
    else:
        logger.error("‚ùå –¢–ï–°–¢–´ –ö–û–ú–ü–û–ù–ï–ù–¢–û–í –ë–õ–û–ö–û–í –ü–†–û–í–ê–õ–ï–ù–´!")
        return False

if __name__ == "__main__":
    success = run_block_components_tests()
    sys.exit(0 if success else 1)
